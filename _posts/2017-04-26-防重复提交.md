---
layout: post
title: 防重复提交策略-分布式锁 
categories: 系统
tags:
- 分布式锁
description: 防重复提交策略-分布式锁
---


作为RD, 偶尔遇到某接口被莫名其妙调用了多次，导致许多重复数据生成，比如连续点击导致产生多个相同的订单。这个时候，就需要把这些非幂等的接口，山寨成幂等操作。可以通过分布式锁的方式实现。

### 一.锁基本条件

1. 锁存储空间

	* 多线程：内存
	* 多进程：共享内存或磁盘
	* 分布式环境：数据库、外部缓存(Redis、Tair等)、Zookeeper、集群中一台独立的主机 

2. 锁需要唯一标识
	
	* 多线程：锁对象的引用
	* 多进程：对象的引用或唯一文件名
	* 分布式：全局唯一锁名称
	
3. 锁至少两种状态

	* 多线程：ReentrantLock的status
	* 多进程：信号量
	* 分布式：有锁/无锁、存在\不存在

### 二、分布式锁进阶条件

1. 可重入
2. 惊群效应
3. 公平锁和非公平锁
4. 阻塞锁和自旋锁

### 三、业务唯一标识

每次请求的唯一标识、比如订单ID等。如果是新增数据操作，可以用请求数据来组建一个唯一标识，比如请求接口+用户ID+门店id\token等等，能唯一标识一个请求。

### 四、防重表

使用业务唯一标识作为防重表的唯一索引，每次请求都根据业务唯一标识向去重表中插入一条数据。执行完请求操作，删除防重表中的数据。重复的请求因为表中唯一索引而插入失败，则返回操作失败，直到第一次的请求完成。可以看出防重表作用是加锁的功能。

### 五、Zookeeper实现

1.利用临时顺序节点实现共享锁的一般做法

首先介绍一下，Zookeeper中有一种节点叫做顺序节点，故名思议，假如我们在/lock/目录下创建节3个点，ZooKeeper集群会按照提起创建的顺序来创建节点，节点分别为/lock/0000000001、/lock/0000000002、/lock/0000000003。

ZooKeeper中还有一种名为临时节点的节点，临时节点由某个客户端创建，当客户端与ZooKeeper集群断开连接，则开节点自动被删除。

利用上面这两个特性，我们来看下获取实现分布式锁的基本逻辑：

客户端调用create()方法创建名为“locknode/guid-lock-”的节点，需要注意的是，这里节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL。客户端调用getChildren(“locknode”)方法来获取所有已经创建的子节点，同时在这个节点上注册上子节点变更通知的Watcher。客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，那么就认为这个客户端获得了锁。如果在步骤3中发现自己并非是所有子节点中最小的，说明自己还没有获取到锁，就开始等待，直到下次子节点变更通知的时候，再进行子节点的获取，判断是否获取锁。释放锁的过程相对比较简单，就是删除自己创建的那个子节点即可。

上面这个分布式锁的实现中，大体能够满足了一般的分布式集群竞争锁的需求。这里说的一般性场景是指集群规模不大，一般在10台机器以内。

不过，细想上面的实现逻辑，我们很容易会发现一个问题，步骤4，“即获取所有的子点，判断自己创建的节点是否已经是序号最小的节点”，这个过程，在整个分布式锁的竞争过程中，大量重复运行，并且绝大多数的运行结果都是判断出自己并非是序号最小的节点，从而继续等待下一次通知——这个显然看起来不怎么科学。客户端无端的接受到过多的和自己不相关的事件通知，这如果在集群规模大的时候，会对Server造成很大的性能影响，并且如果一旦同一时间有多个节点的客户端断开连接，这个时候，服务器就会像其余客户端发送大量的事件通知——这就是所谓的惊群效应。而这个问题的根源在于，没有找准客户端真正的关注点。

我们再来回顾一下上面的分布式锁竞争过程，它的核心逻辑在于：判断自己是否是所有节点中序号最小的。于是，很容易可以联想的到的是，每个节点的创建者只需要关注比自己序号小的那个节点。

2. 利用临时顺序节点实现共享锁的改进实现

下面是改进后的分布式锁实现，和之前的实现方式唯一不同之处在于，这里设计成每个锁竞争者，只需要关注”locknode”节点下序号比自己小的那个节点是否存在即可。

算法思路：对于加锁操作，可以让所有客户端都去/lock目录下创建临时顺序节点，如果创建的客户端发现自身创建节点序列号是/lock/目录下最小的节点，则获得锁。否则，监视比自己创建节点的序列号小的节点（比自己创建的节点小的最大节点），进入等待。

对于解锁操作，只需要将自身创建的节点删除即可。

3. 开源实现

[menagerie](https://github.com/sfines/menagerie)

### 六、分布式锁-Tair实现

借助于Tair的expireLock实现。通过锁状态和过期时间戳来共同判断锁是否存在：只有锁已经存在且没有过期的状态才判定为有锁状态。在有锁状态下，不能加锁， 能通过大于过期时间的时间戳进行解锁；在无锁状态下，可以加锁。发起请求时，系统去Tair缓存中查询是否存在该请求的业务唯一标识，如果不存在，则向Tair增加Key为业务唯一标识的数据。如果Tari中存在该业务唯一标识的数据，且处于锁定状态，则判定是重复请求。


### 参考文档：
http://blog.csdn.net/havarduniv/article/details/42678663