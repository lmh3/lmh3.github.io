---
layout: post
title: 从搜索接口看缓存穿透和雪崩效应
categories: 缓存
tags: 
- 缓存击穿
- 缓存雪崩
description: 从搜索接口看缓存穿透和雪崩效应
---
### 一、背景

#### 1.问题现象
某业务方在凌晨，批量调用搜索接口上百万次，且超过90%的搜索是无结果的。业务方接口超时设置的是0.2s, 大流量读取DB同一张表导致部分请求超时中端，产生499，约0.011%请求超时。
![Alt text](/images/QPS.png)
                                                图1 ： QPS
 ![Alt text](/images/499.png)
                                                图2：499

#### 2.问题的原因
读取缓存的流程：
![Alt text](/images/liucheng.png)
缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端数据库系统查找。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力，这就叫做缓存穿透。

### 二、缓存穿透与缓存雪崩
`缓存穿透`：
如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

`缓存雪崩` stampeding herd：
由于Cache层承载着大量请求，有效的保护了Storage层(通常认为此层抗压能力稍弱)，所以Storage的调用量实际很低。如果Cache层由于某些原因(大量缓存过期、宕机、cache服务挂了或者不响应了)整体crash掉了，也就意味着所有的请求都会达到DB层。       
危害：
对数据库CPU和内存造成巨大压力，前端连接数不够、查询阻塞、响应时间增加。

### 三、如何发现：   
我们可以分别记录cache命中数, DB命中数，以及总调用量。   统计缓存命中率、DD命中率、空命中率。如果发现空命中（cache, DB都没有命中）较多，可能就会在缓存穿透问题。

### 四、如何解决

#### 1.缓存空数据
对查询结果为空的情况也进行缓存，缓存一个默认空标志。以后对这些数据的访问，直接就能在缓存中查到，就不需再查数据库了，通过查询缓存发现得到的为空的标志，就直接返回。
缺点是维护成本增加，需要解决一致性问题。在insert操作时删除掉缓存。耗费更多的缓存空间，所以尽量设置较短的过期时间。

#### 2.增加过滤器
根据数据的数据本身的特点，对于能判断出来DB中明显不存在的，可以直接返回空。比如搜索接口，判断参数取值是否在特定范围内，参数长度是否符合要求等。
布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉。此方法适用于数据相对固定实时性低。

#### 3.对缓存加锁
如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。
tair的`version机制`可以实现类似的锁机制。Tair中存储的每个数据都有版本号，版本号在每次更新后都会递增，相应的，在Tair put接口中也有此version参数，这个参数是为了解决并发更新同一个数据而设置的，类似于乐观锁。很多情况下，更新数据是先get，修改get回来的数据，然后put回系统。如果有多个客户端get到同一份数据，都对其修改并保存，那么先保存的修改就会被后到达的修改覆盖，从而导致数据一致性问题。

tair version机制是：

1) 如果put新数据且没有设置版本号，会自动将版本设置成1。

2) 如果put是更新老数据且没有版本号，或者put传来的参数版本与当前版本一致，版本号自增1。

3) 如果put是更新老数据且传来的参数版本与当前版本不一致，更新失败，返回VersionError。

4) put时传入的version参数为0，则强制更新成功，版本号自增1。


#### 4.避免大量同时失效
缓存过期机制理论上能够将各个客户端的数据失效时间均匀地分布在时间轴上，不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。
缓存失效时间设置为随机的方式，比如5~10分钟间的随机数作为失效时间。

#### 5.二级缓存
缓存两份数据，一份失效时间设置为短期， 一份失效时间设置为长期。
